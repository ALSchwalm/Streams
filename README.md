# C++ Streams

The purpose of this project is to provide sequential streams similar to Java 8
Streams to the C++ language. These streams are designed to work well on their
own and also integrate well into existing C++ STL frameworks.

# Examples

## Creation from containers

Streams are easy to create from existing containers in the standard C++ way.

```cpp
std::vector<int> x = {1,2,3,4,5};
Stream<int> st(x.begin(), x.end());
```

This stream will now read from the vector `x` and hold its data.

## Stream generation


There are a number of stream operations that produce streams, given no initial
stream. These are as follows:

### Generate

The static `generate` method takes a function and produces an infinite stream
generated by repeatedly calling the function and taking its output:

```cpp
auto st = Stream<int>::generate([]() {
    static int counter = 0;
    return ++counter;
});
// Stream contains the sequence 1, 2, 3, ...
```

### Iterate

The static `iterate` method takes an initial value and a function that takes a
single argument of the stream type and returns a value of the stream type. The
stream is then produced by repeatedly applying the function to its previous
result. Thus producing the stream $f(x)$, $f(f(x))$, $f(f(f(x)))$, $\dots$ and so on.
In the following example, we produce a stream that investigates the [Collatz
conjecture](http://en.wikipedia.org/wiki/Collatz_conjecture):

```cpp
auto st = Stream<int>::iterate(1245, [](int x) {
    if(x % 2 == 0) return x / 2;
    return 3 * x + 1;
});
```

### Repeat

The static `repeat` method produces an infinite stream whose contents are all the
same element.

```cpp
auto st = Stream<int>::repeat(0); // stream of infinite 0's.
```

This is then well used in conjunction with methods such as partial sum:

```cpp
auto st = Stream<int>::repeat(1).partial_sum();
// stream contains 1, 2, 3, ...
```

## Saving streams

To print out a stream simply use the `print_to` method:

```cpp
st.print_to(std::cout); // 1 2 3 4 5
```

To save to another container, use the `copy_to` method which works almost
identically to `std::copy`.

```cpp
std::set<int> result;
st.copy_to(std::inserter(result, result.end()));
```

Note that the `print_to` method is simply a convenience for `copy_to` in the
following way:

```cpp
st.copy_to(std::ostream_iterator<int>(std::cout, " "));
// equivalent to st.print_to(std::cout, " ");
```

To save to standard containers use the `to_vector` and `to_list` operations:

```cpp
std::vector<int> result = st.to_vector();
```

And:

```
std::list<int> result = st.to_list();
```

## Intermediate stateless stream operations

There are a number of intermediate stream operations (take in a stream and
convert it into a new stream), which do not require any state to be held and
thus will evaluate lazily.

### Filter

Only allows elements that pass the given predicate.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .filter([](int x) {
        return x % 2 == 0
    });
// Stream now contains only even positive integers
```

### Map

Applies a transformation to every element of the stream, possibly changing type.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .map([](int x) {
        return x * x;
    });
// Stream of perfect squares
```

### Flat Map

Applies a transformation to every element of the stream, that is expected to return
a stream as a result. The resulting stream is the concatenation of these output
streams.

```cpp
Stream<int>::repeat(1)
    .partial_sum()
    .flat_map([](int x) {
        return Stream<int>::repeat(1)
            .partial_sum()
            .limit(x);
    });
// Stream contains 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ...
```

### Limit

Ensures that a stream contains a maximum number of elements.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .limit(5);
// Stream contains 1, 2, 3, 4, 5
```

### Skip

Skips the first k elements of a stream.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .skip(10);
// Stream contains 11, 12, 13, ...
```

### Take while/until

Take while/until take elements of the stream until a given predicate comes to a
certain end state. Take while will grab elements until the predicate becomes
false, and take until grabs until it becomes true.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .take_while([](int x) {
        return x < 5;
    });
// Stream contains 1, 2, 3, 4
```

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .take_until([](int x) {
        return x > 5;
    });
// Stream contains 1, 2, 3, 4, 5
```

### Drop while/until

Drops elements from the stream until a given predicate comes to a certain state.
The stream then contains the elements only after that.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .drop_while([](int x) {
        return x < 5;
    });
// Stream contains 5, 6, 7, ...
```

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .drop_until([](int x) {
        return x > 5;
    })
// Stream contains 6, 7, 8, ...
```

### Peek

Allows the stream owner to peek into the state of a stream in a lazy manner.
When a value passes through a peek, it simply executes a function on the value,
and then returns the value.

```cpp
vector<int> result;
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .filter([](int x) { x % 3 == 0; })
    .limit(3)
    .peek([](int x) {
        std::cout << "Value = " << x << std::endl;
    })
    .copy_to(std::back_inserter(result))
```

Produces the following output:

```
Value = 3
Value = 6
Value = 9
```

### Adjacent Difference

Computes the pairwise differences of elements in the stream.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .map([](int x) { return x * x; })
    .adjacent_difference();
// Stream contains 3, 5, 7, 9, ...
```

### Partial Sum

Computes the partial sums of the elements of the stream.

```cpp
std::vector<int> v = {1, 5, 3, 7, -2, 6};
Stream<int> st(v.begin(), v.end())
    .partial_sum();
// Stream contains 1, 6, 9, 16, 14, 20
```

This is allows a convenient way of producing a counting stream:

```cpp
Stream<int>::repeat(1).partial_sum() // 1, 2, 3, ...
```

### Zip

Takes two streams an zips them together so that the result is a stream of
tuples. The length of the resulting stream is the length of the shorter of the
two streams. The `zip_with` method is specialized so that if either of the input
streams is a stream of tuples, the result is a concatenation of the tuples in
the two streams.

```cpp
std::vector<std::string> input = {"Hello", "this", "is", "a", "stream"};
Stream<std::string> st(input.begin(), input.end())
    .zip_with(Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .print_to(std::cout, "\n"); // Stream of std::tuple<std::string, int>
// Output:
// (Hello, 1)
// (this, 2)
// (is, 3)
// (a, 4)
// (stream, 5)
```

Note that we've included a `operator<<` overload for tuples. Zipping multiple
times:
```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip_with(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .zip_with(Stream<int>::iterate(0, [](int x) { return x + 1; }))
// Stream is now a stream of std::tuple<int, int, int> which contains
// (1, 11, 21), (2, 12, 22), (3, 13, 23), ...
```

One particularly nice tuple operation we've included is a function called `splat`
which takes a function and returns a function that takes a tuple and splats that
tuples elements in as the arguments to the function. For example:

```cpp
auto splatted = splat([](std::string x, int y) {
    return x.length() + y;
});
splatted(std::make_tuple("Hello", 5)) // returns 10
```

This is useful, because it makes working with zipped streams particularly easy.
So instead of having to do the ugly and unreadable:

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip_with(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .map([](const std::tuple<int, int>& tup) {
        return std::get<0>(tup) * std::get<1>(1);
    });
```

You can now have the following:

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip_with(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .map(splat([](int first, int second) {
        return first * second;
    }));
```

### Concat

Concatenates the given stream to the end of the current stream, to be processed when the current stream reaches its end.

```cpp
vector<int> x = {4, 5, 6};
vector<int> y = {1, 2, 3};
Stream<int> st(x.begin(), x.end())
    .concat(Stream<int>(y.begin(), y.end()));
// Stream contains 4, 5, 6, 1, 2, 3
```

### Merge

### Set union

### Set intersection

### Set difference

### Set symmetric difference

## Intermediate stateful stream operations

### State point

Forces the stream to collect its state before continuing with operations. This
is a good way to allow a complete peek into the data  at a certain point in the
program.

```cpp
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .peek([](int x) {
        std::cout << "x = " << x << std::endl;
    })
    .limit(3)
    .state_point()
    .map([](int x) { return 2 * x; })
    .for_each([](int x) {
        std::cout << "2x = " << x << std::endl;
    });
```

Produces the following output:

```
x = 1
x = 2
x = 3
2x = 2
2x = 4
2x = 6
```

Without the `state_point`, the following would have been the output:

```
x = 1
2x = 2
x = 2
2x = 4
x = 3
2x = 6
```

### Sort

Sorts the contents of the stream.

```cpp
std::vector<int> v = {3, 1, 5, 2, 8};
std::vector<int> sorted = Stream<int>(v.begin(), v.end())
    .sort()
    .as_vector();
// sorted = {1, 2, 3, 5, 8}
```

### Distinct

Removes duplicate elements from the stream and returns the results in sorted order.

```cpp
std::vector<int> v = {3, 1, 3, 5, 2, 5, 8, 8};
Stream<int>(v.begin(), v.end())
    .distinct()
    .print_to(std::cout)
// Prints 1 2 3 5 8
```

###
