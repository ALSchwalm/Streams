# C++ Streams

The purpose of this project is to provide sequential streams similar to Java 8
Streams to the C++ language. These streams are designed to work well on their
own and also integrate well into existing C++ STL frameworks.

# Examples

## Creation from containers

Streams are easy to create from existing containers in the standard C++ way.

```c++
std::vector<int> x = {1,2,3,4,5};
Stream<int> st(x.begin(), x.end());
```

This stream will now read from the vector x and hold its data.

## Stream generation

There are two main stream operations that produce streams: generate and iterate.
The static `generate` method takes a function and produces an infinite stream
generated by repeatedly calling the function and taking its output:

```c++
auto st = Stream<int>::generate([]() {
    static int counter = 0;
    return ++counter;
});
// Stream contains the sequence 1, 2, 3, ...
```

The static `iterate` method takes an initial value and a function that takes a
single argument of the stream type and returns a value of the stream type. The
stream is then produced by repeatedly applying the function to its previous
result. Thus producing the stream f(init), f(f(init)), f(f(f(init))), and so on.
In the following example, we produce a stream that investigates the [Collatz
conjecture](http://en.wikipedia.org/wiki/Collatz_conjecture):

```c++
auto st = Stream<int>::iterate(1245, [](int x) {
    if(x % 2 == 0)
        return x / 2;
    return 3 *x + 1 
});
```

## Saving treams

To print out a stream simply use the `print_to` method:

```c++
st.print_to(std::cout); // 1 2 3 4 5
```

To save to another container, use the `copy_to` method which works almost 
identically to `std::copy`.

```c++
std::vector<int> result;
st.copy_to(std::back_inserter(result));
```

Note that the `print_to` method is simply a convenience for `copy_to` in the
following way:

```c++
st.copy_to(std::ostream_iterator<int>(std::cout, " "));
// equivalent to st.print_to(std::cout, " ");
``` 

## Intermediate stateless stream operations

There are a number of intermediate stream operations (take in a stream and 
convert it into a new stream), which do not require any state to be held and
thus will evaluate lazily.

### Filter

Only allows elements that pass the given predicate.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .filter([](int x) {
        return x % 2 == 0
    });
// Stream now contains only even positive integers
```

### Map

Applies a transformation to every element of the stream, possibly changing type.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .map([](int x) {
        return x * x;
    });
// Stream of perfect squares
```

### Limit

Ensures that a stream contains a maximum number of elements.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .limit(5);
// Stream contains 1, 2, 3, 4, 5
```

### Skip

Skips the first k elements of a stream.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .skip(10);
// Stream contains 11, 12, 13, ...
```

### Take while/until

Take while/until take elements of the stream until a given predicate comes to a
certain end state. Take while will grab elements until the predicate becomes
false, and take until grabs until it becomes true.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .take_while([](int x) {
        return x < 5;
    });
// Stream contains 1, 2, 3, 4
```

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .take_until([](int x) {
        return x > 5;
    });
// Stream contains 1, 2, 3, 4, 5
```

### Drop while/until

Drops elements from the stream until a given predicate comes to a certain state.
The stream then contains the elements only after that.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .drop_while([](int x) {
        return x < 5;
    });
// Stream contains 5, 6, 7, ...
```

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .drop_until([](int x) {
        return x > 5;
    })
// Stream contains 6, 7, 8, ...
```

### Peek

Allows the stream owner to peek into the state of a stream in a lazy manner.
When a value passes through a peek, it simply executes a function on the value,
and then returns the value.

```c++
vector<int> result;
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .filter([](int x) { x % 3 == 0; })
    .limit(3)
    .peek([](int x) {
        std::cout << "Value = " << x << std::endl;
    })
    .copy_to(std::back_inserter(result))
// Output:
// Value = 3
// Value = 6
// Value = 9
```

### Adjacent Difference

Computes the pairwise differences of elements in the stream.

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; })
    .map([](int x) { return x * x; })
    .adjacent_difference();
// Stream contains 3, 5, 7, 9, ...
```

### Zip

Takes two streams an zips them together so that the result is a stream of
tuples. The length of the resulting stream is the length of the shorter of the
two streams. The `zip` method is specialized so that if either of the input
streams is a stream of tuples, the result is a concatenation of the tuples in
the two streams.

```c++
std::vector<std::string> input = {"Hello", "this", "is", "a", "stream"};
Stream<std::string> st(input.begin(), input.end())
    .zip(Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .print_to(std::cout, "\n"); // Stream of std::tuple<std::string, int>
// Output:
// (Hello, 1)
// (this, 2)
// (is, 3)
// (a, 4)
// (stream, 5)
```

Note that we've included a `operator<<` overload for tuples. Zipping multiple
times:
```c++
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .zip(Stream<int>::iterate(0, [](int x) { return x + 1; }))
// Stream is now a stream of std::tuple<int, int, int> which contains
// (1, 11, 21), (2, 12, 22), (3, 13, 23), ...
```

One particularly nice tuple operation we've included is a function called `splat`
which takes a function and returns a function that takes a tuple and splats that
tuples elements in as the arguments to the function. For example:

```c++
auto splatted = splat([](std::string x, int y) {
    return x.length() + y; 
});
splatted(std::make_tuple("Hello", 5)) // returns 10
``` 

This is useful, because it makes working with zipped streams particularly easy.
So instead of having to do the ugly and unreadable:

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .map([](const std::tuple<int, int>& tup) {
        return std::get<0>(tup) * std::get<1>(1);
    });
```

You can now have the following:

```c++
Stream<int>::iterate(0, [](int x) { return x + 1; }))
    .zip(Stream<int>::iterate(10, [](int x) { return x + 1; }))
    .map(splat([](int first, int second) {
        return first * second;
    }));
```