# C++ Streams

The purpose of this project is to provide sequential streams similar to Java 8
Streams to the C++ language. These streams are designed to work well on their
own and also integrate well into existing C++ STL frameworks.

# Creation from containers

Streams are easy to create from existing containers in the standard C++ way.

```cpp
std::vector<int> x = {1,2,3,4,5};
Stream<int> st(x.begin(), x.end());
```

This stream will now read from the vector `x` and hold its data. There is also a
class of static methods `MakeStream` to allow for creation of streams with an
implicit type. Thus the same can be done in the following ways:

```cpp
std::vector<int> x = //...
auto stream1 = MakeStream::from(x.begin(), x.end());
auto stream2 = MakeStream::from(x);
```

The `MakeStream::from` method can also be used to create streams from arrays and
initializer lists:

```cpp
int x[] = {1,2,3,4,5};
auto stream1 = MakeStream::from(x, 5);
auto stream2 = MakeStream::from({1,2,3,4,5});

```

# Stream generation

There are a number of stream operations in `MakeStream` that produce streams,
given no initial stream. These are as follows:

## Singleton

The static `singleton` method creates a stream with the given value and only
that value.

```cpp
MakeStream::singleton(5).print_to(std::cout);
// Prints 5
```

## Generate

The static `generate` method takes a function and produces an infinite stream
generated by repeatedly calling the function and taking its output:

```cpp
auto st = MakeStream::generate([]() {
    static int counter = 0;
    return ++counter;
});
// Stream contains the sequence 1, 2, 3, ...
```

## Iterate

The static `iterate` method takes an initial value and a function that takes a
single argument of the stream type and returns a value of the stream type. The
stream is then produced by repeatedly applying the function to its previous
result. Thus producing the stream x, f(x), f(f(x)), f(f(f(x))), ... and so on.
In the following example, we produce a stream that investigates the
[Collatz conjecture](http://en.wikipedia.org/wiki/Collatz_conjecture):

```cpp
auto st = MakeStream::iterate(1245, [](int x) {
    if(x % 2 == 0) return x / 2;
    return 3 * x + 1;
});
```

## Counter

The static `counter` method takes an initial value and returns a stream produced
by incrementing that value indefinitely.

```cpp
auto st = MakeStream::counter(5); // 5, 6, 7, ...
```

The counter method is equivalent to the following:

```cpp
template<typename T>
Stream<T> make_stream_counter(T initial) {
    return MakeStream::iterate(initial, [](T& value) {
           return ++value;
        });
}

```

## Repeat

The static `repeat` method produces an infinite stream whose contents are all
the same element.

```cpp
auto st = MakeStream::repeat(0); // stream of infinite 0's.
auto st2 = MakeStream::repeat(5, 10) // stream of 10 5's.
```

This is then well used in conjunction with methods such as partial sum:

```cpp
auto st = MakeStream::repeat(1).partial_sum();
// stream contains 1, 2, 3, ...
```

## Cycle

The static `cycle` method produces an infinite stream whose contents cycle through
a given input sequence.

```cpp
vector<int> x{1, 3, 8};
MakeStream::cycle(x) // Contains 1, 3, 8, 1, 3, 8, 1, ...
MakeStream::cycle(x, 2) // Contains 1, 3, 8, 1, 3, 8.
```

# Intermediate stateless stream operations

There are a number of intermediate stream operations (take in a stream and
convert it into a new stream), which do not require any state to be held and
thus will evaluate lazily.

## Filter

Only allows elements that pass the given predicate.

```cpp
MakeStream::counter(1)
    .filter([](int x) {
        return x % 2 == 0
    });
// Stream now contains only even positive integers
```

## Map

Applies a transformation to every element of the stream, possibly changing type.

```cpp
MakeStream::counter(1)
    .map([](int x) {
        return x * x;
    });
// Stream of perfect squares
```

## Flat Map

Applies a transformation to every element of the stream, that is expected to return
a stream as a result. The resulting stream is the concatenation of these output
streams.

```cpp
MakeStream::counter(1)
    .flat_map([](int x) {
        return MakeStream::counter(1)
            .limit(x);
    });
// Stream contains 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ...
```

## Limit

Ensures that a stream contains a maximum number of elements.

```cpp
MakeStream::counter(1)
    .limit(5);
// Stream contains 1, 2, 3, 4, 5
```

## Skip

Skips the first k elements of a stream.

```cpp
MakeStream::counter(1)
    .skip(10);
// Stream contains 11, 12, 13, ...
```

## Slice

Takes a sliced subset of the elements in the stream. The operator is of the form
```stream.slice(startIndex, endIndex, increment)```, and the result is 
a stream starting from the `startIndex`, up to (but not including) `endIndex` by steps
of size `increment`. By default `increment` is 1.

```cpp
MakeStream::counter(0).slice(5, 10) // 5 6 7 8 9
MakeStream::counter(0).slice(1, 8, 2) // 1 3 5 7
```

Note that `limit(n)` is equivalent to `slice(0, n)`.


## Slice to End

A version of the slice operation which allows an unbounded slice. Slices are
taken from a given starting index and go by a given step size.

```cpp
MakeStream::counter(0).slice_to_end(0, 5) // 0 5 10 15 ...
MakeStream::counter(0).slice_to_end(3, 2) // 3 5 7 9 ...
```

Note that `skip(n)` is equivalent to `slice_to_end(n, 1)`.

## Take while

Takes elements from the stream until the given predicate becomes false.

```cpp
MakeStream::counter(1)
    .take_while([](int x) {
        return x < 5;
    });
// Stream contains 1, 2, 3, 4
```

## Drop while

Drops elements from the stream until the given predicate becomes false.

```cpp
MakeStream::counter(1)
    .drop_while([](int x) {
        return x < 5;
    });
// Stream contains 5, 6, 7, ...
```

## Peek

Allows the stream owner to peek into the state of a stream in a lazy manner.
When a value passes through a peek, it simply executes a function on the value,
and then returns the value.

```cpp
vector<int> result;
MakeStream::counter(1)
    .filter([](int x) { x % 3 == 0; })
    .limit(3)
    .peek([](int x) {
        std::cout << "Value = " << x << std::endl;
    })
    .copy_to(std::back_inserter(result))
```

Produces the following output:

```
Value = 3
Value = 6
Value = 9
```

## Adjacent Distinct

Removes adjacent duplicates from the stream.

```cpp
MakeStream::from({1, 1, 3, 2, 2, 5, 5, 5, 5, 2, 3, 3})
    .adjacent_distinct();
// Stream contains 1, 3, 2, 5, 2, 3
```

## Adjacent Difference

Computes the pairwise differences of elements in the stream.

```cpp
MakeStream::counter(1)
    .map([](int x) { return x * x; })
    .adjacent_difference();
// Stream contains 3, 5, 7, 9, ...
```

## Partial Sum

Computes the partial sums of the elements of the stream.

```cpp
MakeStream::from({1, 5, 3, 7, -2, 6})
    .partial_sum();
// Stream contains 1, 6, 9, 16, 14, 20
```

## Zip

Takes two streams an zips them together so that the result is a stream of
tuples. The length of the resulting stream is the length of the shorter of the
two streams. The `zip_with` method is specialized so that if either of the input
streams is a stream of tuples, the result is a concatenation of the tuples in
the two streams.

```cpp
std::vector<std::string> input = {"Hello", "this", "is", "a", "stream"};
MakeStream::from(input)
    .zip_with(MakeStream::counter(1))
    .print_to(std::cout, "\n"); // Stream of std::tuple<std::string, int>
// Output:
// (Hello, 1)
// (this, 2)
// (is, 3)
// (a, 4)
// (stream, 5)
```

Note that we've included a `operator<<` overload for tuples. Zipping multiple
times:
```cpp
MakeStream::counter(0)
    .zip_with(MakeStream::counter(10))
    .zip_with(MakeStream::counter(20))
// Stream is now a stream of std::tuple<int, int, int> which contains
// (0, 10, 20), (1, 11, 21), (2, 12, 22), ...
```

One particularly nice tuple operation we've included is a function called `splat`
which takes a function and returns a function that takes a tuple and splats that
tuples elements in as the arguments to the function. For example:

```cpp
auto splatted = splat([](std::string x, int y) {
    return x.length() + y;
});
splatted(std::make_tuple("Hello", 5)) // returns 10
```

This is useful, because it makes working with zipped streams particularly easy.
So instead of having to do the ugly and unreadable:

```cpp
MakeStream::counter(1))
    .zip_with(MakeStream::counter(11))
    .map([](const std::tuple<int, int>& tup) {
        return std::get<0>(tup) * std::get<1>(1);
    });
```

You can now have the following:

```cpp
MakeStream::counter(1)
    .zip_with(MakeStream::counter(11))
    .map(splat([](int first, int second) {
        return first * second;
    }));
```

Zip with can also be provided a function that takes arguments of types of the
two streams and returns a stream produced by repeated calling of the function
on index equivalent elements of both streams:

```cpp
MakeStream::counter(1.0)
    .zip_with(MakeStream::counter(2.0), [](double a, double b) {
        return std::complex<double>(a, b);
    });
// Stream contains 1+2i, 2+3i, 3+4i, ...
```

## Concat

Concatenates the given stream to the end of the current stream, to be processed
when the current stream reaches its end.

```cpp
vector<int> x = {4, 5, 6};
vector<int> y = {1, 2, 3};
MakeStream::from(x)
    .concat(Makestream::from(y));
// Stream contains 4, 5, 6, 1, 2, 3
```

## Pad

Concatenates an infinite stream of repeated values to the end of the current
stream.

```cpp
vector<int> x = {1, 2, 3};
MakeStream::from(x)
    .pad(0);
// Stream contains 1, 2, 3, 0, 0, 0, ...
```

Note that `stream.pad(value)` is equivalent to:

`stream.concat(MakeStream::repeat(value))`

## Merge

*Note: This operator only applies to streams that are guaranteed to be sorted.
Use on any other streams produces undefined results.*

Computes the merging of two streams (the merge step in mergesort).

```cpp
Stream<int> left = MakeStream::from({1, 2, 4, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left.merge_with(right); // 1, 2, 2, 4, 4, 5, 12, 12, 13, 17, 17, 18
```
## Union

*Note: This operator only applies to streams that are guaranteed to be sorted and
distinct. Use on any other streams produces undefined results.*

Computes the set union of two streams.

```cpp
Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left.union_with(right); // 1, 2, 4, 12, 13, 17, 18
```

## Intersection

*Note: This operator only applies to streams that are guaranteed to be sorted and
distinct. Use on any other streams produces undefined results.*

Computes the set intersection of two streams.

```cpp
Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left.intersection_with(right); // 2, 12, 17
```

## Difference

*Note: This operator only applies to streams that are guaranteed to be sorted and
distinct. Use on any other streams produces undefined results.*

Computes the set difference of two streams with the base stream on the left,
and the argument stream on the right.

```cpp
Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left.difference_with(right); // 1, 4, 13
```

## Symmetric difference

*Note: This operator only applies to streams that are guaranteed to be sorted and
distinct. Use on any other streams produces undefined results.*

Computes the set symmetric difference of two streams.

```cpp
Stream<int> left = MakeStream::from({1, 2, 4, 12, 13, 17});
Stream<int> right = MakeStream::from({2, 5, 12, 17, 18});
left.symmetric_difference_with(right); // 1, 4, 5, 13, 18
```


# Intermediate stateful stream operations

These operations will introduce a state point in the pipeline, and will therefore
require more than O(1) space.

## State point

Forces the stream to collect its state before continuing with operations. This
is a good way to allow a complete peek into the data  at a certain point in the
program.

```cpp
MakeStream::counter(1)
    .peek([](int x) {
        std::cout << "x = " << x << std::endl;
    })
    .limit(3)
    .state_point()
    .map([](int x) { return 2 * x; })
    .for_each([](int x) {
        std::cout << "2x = " << x << std::endl;
    });
```

Produces the following output:

```
x = 1
x = 2
x = 3
2x = 2
2x = 4
2x = 6
```

Without the `state_point`, the following would have been the output:

```
x = 1
2x = 2
x = 2
2x = 4
x = 3
2x = 6
```

## Sort

Sorts the contents of the stream.

```cpp
std::vector<int> sorted = MakeStream::from({3, 1, 5, 2, 8})
    .sort()
    .to_vector();
// sorted = {1, 2, 3, 5, 8}
```

## Distinct

Removes duplicate elements from the stream and returns the results in sorted order.

```cpp
MakeStream::from({3, 1, 3, 5, 2, 5, 8, 8})
    .distinct()
    .print_to(std::cout)
// Prints 1 2 3 5 8
```

# Terminal stream operations

Several terminal stream operations will produce an error if the stream is empty 
and no default value is provided. The error produced is an `EmptyStreamException`.

## Count

`stream.count()` returns the number of elements in the stream.

## Sum

`stream.sum()` sums the elements of the stream. There are two forms of this
operators, one with no arguments, which will throw an error if the stream is
empty, the second which takes an element which is the additive identity of the
stream eleements, and will return this value if the stream is empty.

## Product

`stream.product()` takes the product of the elements of the stream. This operator
also has a no-arguments error-producing form and a form which takes a multiplicative
identity in case of an empty stream.

## Max

`stream.max()` returns the maximum element of the stream, throws an exception if
the stream is empty.

## Min

`stream.min()` Returns the minimum element of the stream, throws an exception
if the stream is empty.

## Min max

`stream.minmax()` returns a pair containing the minimum and maximum elements of
the stream, throws an exception if the stream is empty.

```cpp
T min, max;
std::tie(min, max) = stream.mimax();
```

## First

`stream.first()` returns the first element of the stream, throws an exception
if the stream is empty.

## Last

`stream.last()` returns the last element of the stream, throws an exception if
the stream is empty.

## Any

`stream.any(predicate)` returns true if some element of the stream matches a
given predicate. If the stream is empty, the result is vacuously false. If the
stream is infinite, this operation will shortcut in the case that an element that
matches the predicate is found.

## All

`stream.all(predicate)` returns true if all the elements of the stream match a
given predicate. If the stream is empty, the result is vacuously false. If the
stream is infinite, this operation will shortcut in the case that an element that
doesnt match the predicate is found.

## None

`stream.none(predicate)` returns true if none of the elements of the stream match
a given predicate. Equivalent to calling `all` with the inverse predicate.

## For each
`stream.for_each(func)` calls some function on each element of the stream.

## Reduce

There are two forms of reduce. The first is of the form:

```cpp
U Stream<T>::reduce(U identity, Accumulator accum);
```

In this case, accumulator must be a function object whose first argument is of
type `U` and whose second argument is of type `T`. If this condition is satisfied,
then `reduce` will iterate through the elements of the stream combining them
with the previous value (starting with `identity`) by using the accumulator,
returning the final output of the accumulation. In the case that the stream is
empty, `identity` is returned. The functionality is equivalent to:

```cpp
U result = identity;
for(T value : stream)
    result = accum(result, value);
return result;
```

For example, `count()` can be implemented as follows:

```cpp
stream.reduce(0,
    [](int prev, auto& value) {
        return prev + 1;
    });
```

The second form of reduce is for handling cases where there is no default value
for an empty stream, and thus produces an error in the case that the stream
is empty. This has the form:

```cpp
U Stream<T>::reduce(IdentityFunction identity, Accumulator accum);
```

The identity function is used to transform the first element of the stream into
an element of the return type. The functionality is as follows (in pseudocode):

```
U result = identity(stream[0]);
for(T value : stream[1...])
    result = accum(result, value);
return result;
```

For example, the `minmax()` method can be implemented as follows:

```cpp
auto to_pair = [](auto& value) {
    return std::make_pair(value, value);
};

auto next_minmax = [](const auto& prev_minmax, auto& value) {
    if(value < prev_minmax.first) {
        return std::make_pair(value, prev_minmax.second);
    } else if (value > prev_minmax.second) {
        return std::make_pair(prev_minmax.first, value);
    } else {
        return prev_minmax;
    }
};

stream.reduce(to_pair, next_minmax);
```

## Copy to

`stream.copy_to(iterator)` copies the contents of the stream into the result
specified by the iterator. This is functionally equivalent to:

```cpp
std::copy(stream.begin(), stream.end(), iterator);
```

## Move to

`stream.move_to(iterator)` moves the elements of the stream into the specified
iterator, just like:

```cpp
std::move(stream.begin(), stream.end(), iterator);
```

## Print to

`stream.print_to(outstream, delimiter)` prints the elements of the stream out to
the specified `ostream`, with `delimiter` in between each element. By default
`delimiter` is a single space. Calling `print_to` is a convenience for the
following

```cpp
stream.copy_to(std::ostream_iterator<T>(out, delimiter));
```

## To standard containers

There are a variety of methods that allow saving to standard library containers:

* `stream.to_vector()`
* `stream.to_list()`
* `stream.to_deque()`
* `stream.to_set()`
* `stream.to_multiset()`